Type 'ant jar' to create the orchestration package library which
supports definition of Event Condition Action rules for orchestrating
JBossTS test scenarios via insertion of event triggers into com.arjuna
methods, either at start of method code or at specific line numbers.

Set up
------
In order to use this library inside JBOSS you need to supply JVM with
the orchestration jar as a java agent. This jar implements

  an agent class which monitors bytecode load operations and selects
  classes which match the compiled rule set as candidates for
  transformation

  the transformer class which inserts trigger calls to invoke rules

  a rule compiler which translates rules into classes which handle the
  trigger method calls (n.b. at present the rules are excuted by
  interpreting the type-checked rule parse tree rather than by
  compiling them but the latter should eventualy follow)

The agent is passed to the JVM using the -javaagent option of the java
command by setting JAVA_OPTS as follows:

export JAVA_OPTS="-javaagent:${HOME}/jboss/workspace/adinn/orchestration/build/lib/orchestration.jar=rule:${HOME}/jboss/workspace/adinn/orchestration/build/lib/orchestration.jar"

The =rule:<jar> option to the -javaagent argument tells the agent
premain to search <jar> for rules, i.e. classes and methods annotated
with, respectively, EventHandlerClass and EventHandler
annotations. The agent will parse them to identify rules for
transforming com.arjuna.* classes. The agent jar contains a simple
test class, org.jboss.jbossts.test.HandlerClass, which defines 4 rules
used for testing a specific scenario in XTS coordinator crash
recovery. See these (or the code :-) to get a taste of what the rule
language offers (that's all foax, for now at least -- sorry).

Rule Definition
---------------
Rules are defined via class and method anotations on a host class. Any
class tagged with an EventHandlerClass annotation is a host class and
is able to define a set of rules. Any static method of a host class
annotated with an EventHandler annotation defines an individual
rule. The EventHandler annotation must define a target class for the
rule, a target method and a target method line number (or -1 for start
of method). Text elements in the annotation specify the rule event,
condition and action. The event handler class and event handler static
method code are available for use in the rule but they need not be
invoked.

The target class may be specified with or without a full package
qualification. If no package is specified then all classes whose
unqualified name equals the target will be candidiates for rule
trigger insertion. Note, however, that for safety triggers will only
be inserted into com.arjuna or org.jboss classes. So, for example,
targetClass="TransactionImple" would match all the transaction
implementation classes in the JTA, JTS and XTS packages but would not
match any org.jboss implementations.

Note that a rule is deliberately not defined using the host class code
(the class tagged with annotation EventHandlerClass).  It is quite
legitimate to call host class methods from within a rule event,
condition or action but they cannot provide the complete definition of
the rule itself.  Rules need to refer to the target class and,
possibly, classes that it references. Defining the rule via the host
class implementation would impose recursive class loader dependencies
between the host class and the class into which it is trying to insert
trigger code.

Note also that classes mentioned in the rule are only identified by
name. Such names are resolved at runtime against a target class and
related classes as they are being loaded into a specific class
loader. So, if a class is loaded more than once then each version of
the class may be a candidate for trigger insertion. As a consequence,
class names emloyed in rules may also be quoted without package
qualification. However, it must be possible for the rule compiler to
translate them unambiguously to fully qualified class names by
inferring the types from the target class and target method signature
identified at transform time or by deriving them from field references
and method signatures of classes associated with the target class and
method.

Rule Events
-----------
An event specification is a list of bindings for variables which can
be referenced during evaluaton of the rule condition and execution of
the rule actions. Bindings are established in the context of the
target method. By default, the target method arguments are pre-bound
using the special syntax $0 (for this, when the target method is not
static) and $1...$N for arguments 1..N of the target method. Further
bindings, using symbolic names for the bound variables, can be
established by assigning a symbolic constant to an expression which
may refer to previously bound variables. For example,

  'coordinator:Coordinator = $0,
   recovered:boolean = coordinator.recovered,
   identifier:String = coordinator.getInstanceIdentifier()'

binds coordinator to the Coordinator instance bound to this in the
triggering method, binds recovered to the value of its boolean field,
recovered, and binds identifier to the String returned by invoking
method getInstanceIdentifier().

The LHS of a binding must be a variable name or a name:type pair. If
the type is omitted it will be inferred from the RHS where
possible. The RHS of a binding is a Java expression which can include
various builtin expressions plus most Java expressions such as static
or instance field accesses and invocations, array dereferences,
operator expressions, method invocations, etc (but *not* assignment
expressions). The RHS of a binding may refer to method argument
variables and to variables bound in earlier bindings but not to its
own variable or later bound variables. Rebinding of variables is not
permitted.

Rule Conditions
---------------
A condition is merely an expression with a boolean result. Expressions
may be complex using the usual operators plus a few syntactically
sugared variants. Conditions may also include method invocations and
references to bound variables. So, for example:

  'engine.isRecovered() AND getCountdown(instanceIdentifier)'

will succeed if engine.isRecovered() returns true and a countdown
identified by instanceIdentifer is active

  'NOT recovered && countDown(instanceIdentifier)'

will succeed if recovered is false and decrementing the countdown
identified by instanceIdentifier renders it inactive.

Rule Actions
------------
An action is a series of expressions which are either method
invocations or builtin invocations. Actions may include references to
bound variables. So, for example,

  'debug("killing prepare attempt"), killThread()'

will print a debug message and abort the target method with a runtime
exception, killing the therad in normal circumstances

  'debug("terminator X it"), killJVM()'

will print a debug message and cause an immediate halt of the JVM.

Expressions
-----------
Expressions occuring in rules can employ most of the available Java
syntax with the notable exception that assignment is only valid at the
top level in an event binding. Certain restrictions currently apply
e.g. the recipient of a method invocation must be either a bound
variable (*not* a dollar variable) or a field reference or series of
field references via a bound vaiable or a static field reference
(e.g. foo.meth(), foo.bar.meth, com.arjuna.foo.meth()). These should
get fixed at some point.

A variety of builtin methods are available. These may be written as
function calls although internally they are treated as invocations of
instance methods on an object identified by an implicit bound variable
$$ of type Rule.Helper. Each time a rule is triggered a Helper
instance is used to store the table of bindings for the trigger method
arguments $0, $1 etc and for event variables. Every public instance
method on class Helper is automatically available as a callable
function in a rule binding, condition or action. For example, Helper
defines a boolean method debug(String) which prints text to
System.out. So, a call to debug("call to debug") will result in a call
to the hhelper's instance method (n.b. debug always returns true,
allowing it to be composed in AND conditions as well invoked as an
action).

Helper provides other builtins which allow countdowns to be initiated,
detected and decremented and allows threads to be blocked on a wait,
resumed and killed. Methods to support rendezvous will be added
soon. Adding a method to Helper automatically makes it available as a
builtin (type-checking happens automically too) so it should be easy
to extend the rule language as nw requirements arise.
