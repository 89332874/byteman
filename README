Type 'ant jar' to create the orchestration package library which
supports definition of Event Condition Action rules for orchestrating
JBossTS test scenarios via insertion of event triggers into com.arjuna
or org.jboss methods, either at start of method code or at specific
line numbers.

Set up
------
In order to use this library inside JBOSS you need to supply JVM with
the orchestration jar as a java agent. This jar implements

  an agent class which monitors bytecode load operations and selects
  classes which match the compiled rule set as candidates for
  transformation

  the transformer class which inserts trigger calls to invoke rules

  a rule compiler which translates rules into classes which handle the
  trigger method calls (n.b. at present the rules are excuted by
  interpreting the type-checked rule parse tree rather than by
  compiling them but the latter should eventualy follow)

The agent is passed to the JVM using the -javaagent option of the java
command by setting JAVA_OPTS as follows:

export JAVA_OPTS="-javaagent:${HOME}/jboss/workspace/adinn/orchestration/build/lib/orchestration.jar=script:${HOME}/jboss/workspace/adinn/orchestration/handler.txt"

The =script:<scriptFile> option to the -javaagent argument tells the
agent premain to search <scriptFile> for rules. Multiple scripts may
be supplied by repeating the =script:<scriptFile> argument separated
by a ','. The agent will parse each script file to identify rules to
be triggered from methods occurring in com.arjuna.* and org.jboss.*
classes. File handler.txt contains an example script which defines 6
rules used for testing a specific scenario in XTS coordinator crash
recovery. See these (or the code :-) to get a taste of what the rule
language offers (that's all foax, for now at least -- sorry).

Rule Definition
---------------

The orchestration package employs Event Condition Action rules
although, strictly, the event component is limited to matching an
invocation of a specific method when execution reaches a particular
soure code line number in the method body. The event automatically
binds the arguments of the trigger method at the point where the rule
is triggered. It may also compute bindings for an optional set of
local variables by evaluating a Java expression. The condition is an
expression with boolean type. The action is a sequence of expressions
of arbitrary type which are only evaluated if the condition is
true. Expressions are composed from builtin operations, references to
static or bound values, method invocations and combinations of
sub-expressions using the usual set of operators. Note that
assignment, new operations and throw operations are not allowed in
expressions.

Rule definitiosn specify a target class, a target method and a target
line number (default is -1) in the method source code. The agent code
identifies classes and methods at load time which match the target
class and name and inserts a trigger call at the specified line which
invokes the rule (or at the method start if the line number is
-1). When execution reaches a trigger point the associated rule is
executed and can performs any delay, synchronization, trace or other
operation appropriate to the test. Normally, control returns to the
trigger method and execution continues by executing the target line.

It is possible for a rule to alter the flow of control. A rule action
can invoke a builtin to 'kill' the current thread, by throwing a
runtime exception. This may not actually kill the thread if the
trigger method code or one of its callers catches a generic exception
but it can be used effectively. Another builtin can be used to signal
other waiting threads and cause them to 'abort'. Finally, a third
builtin allows the JVM to be halted. It is possible to call arbitrary
Java code inside rule actions so the opportunites for messing around
with control flow extend beyond these builtin options.

The target class may be specified with or without a full package
qualification. If no package is specified then all classes whose
unqualified name equals the target will be candidiates for rule
trigger insertion. Note, however, that for safety triggers will only
be inserted into com.arjuna or org.jboss classes. So, for example,
targetClass="TransactionImple" would match all the transaction
implementation classes in the JTA, JTS and XTS packages but would not
match any org.jboss implementations.

Class names mentioned in rules are resolved against a candidate
trigger class and related classes at runtime as they are being loaded
into a specific class loader. If the type checker cannot resolve the
declared types of variables, methods and fields mentioned in the rule
against candidate classes it prints type check errors and disables
execution of the rule for the class in question. Note that if a class
is loaded more than once by different class loaders then each version
of the class may be a candidate for trigger insertion from the same
rule. Use of unqualified class names (i.e. without package) also
potentially allows a rule to be applied in more than one case.

Method names may be specified using just the method name or by
supplying the name and a bracketed list of parameters, optionally
followed by a return type. If just the name is specified then any
method with the correct name will be considered as a candidate for
trigger insertion. Again, this allows the rule to be applied to
multiple cases (this is only really useful if the line number is -1).
If a signature is provided then the trigger call will only be inserted
into a method whose arguments match the signature. The types employed
in a signature may also omit the package name if desired.

Note that a rule is deliberately defined via a script rather than
using annotations, especially not annotations on the trigger class.
Rules refer to the target class and, possibly, classes that it
references by name only. Defining the rule via annotations on the
target class implementation would require loading the class before
having the chance to modify its byte code. Also, the point of using
rules is so that tests may be rigged up without having to redefine and
rebuild the test code base.

Rule Events
-----------
An event specification is a list of bindings for variables which can
be referenced during evaluaton of the rule condition and execution of
the rule actions. Bindings are established in the context of the
target method. By default, the target method arguments are pre-bound
using the special syntax $0 (for this, when the target method is not
static) and $1...$N for arguments 1..N of the target method. Further
bindings, using symbolic names for the bound variables, can be
established by assigning a symbolic constant to an expression which
may refer to previously bound variables or static data. For example,

  'coordinator:Coordinator = $0,
   recovered:boolean = coordinator.recovered,
   identifier:String = coordinator.getInstanceIdentifier()'

binds coordinator to the Coordinator instance bound to this in the
triggering method, binds recovered to the value of its boolean field,
recovered, and binds identifier to the String returned by invoking
method getInstanceIdentifier().

The LHS of a binding must be a variable name or a name:type pair. If
the type is omitted it will be inferred from the RHS where
possible. The RHS of a binding is a Java expression which can include
various builtin expressions plus most Java expressions such as static
or instance field accesses and invocations, array dereferences,
operator expressions, method invocations, etc (but *not* assignment
expressions). The RHS of a binding may refer to method argument
variables and to variables bound in earlier bindings but not to its
own variable or later bound variables. Rebinding of variables is not
permitted.

Rule Conditions
---------------
A condition is merely an expression with a boolean result. Expressions
may be complex using the usual operators plus a few syntactically
sugared variants. Conditions may also include method invocations and
references to bound variables. So, for example:

  'engine.isRecovered() AND getCountdown(instanceIdentifier)'

will succeed if engine.isRecovered() returns true and a countdown
identified by instanceIdentifer is active

  'NOT recovered && countDown(instanceIdentifier)'

will succeed if recovered is false and decrementing the countdown
identified by instanceIdentifier renders it inactive.

Rule Actions
------------
An action is a series of expressions which are either method
invocations or builtin invocations. Actions may include references to
bound variables. So, for example,

  'debug("killing prepare attempt"), killThread()'

will print a debug message and abort the target method with a runtime
exception, killing the therad in normal circumstances

  'debug("terminator X it"), killJVM()'

will print a debug message and cause an immediate halt of the JVM.

Expressions
-----------
Expressions occuring in rules can employ most of the available Java
syntax with the notable exception that assignment is only valid at the
top level in an event binding. Certain restrictions currently apply
e.g. the recipient of a method invocation must be either a bound
variable (*not* a dollar variable) or a field reference or series of
field references via a bound vaiable or a static field reference
(e.g. foo.meth(), foo.bar.meth, com.arjuna.foo.meth()). These should
get fixed at some point.

A variety of builtin methods are available. These may be written as
function calls although internally they are treated as invocations of
instance methods on an object identified by an implicit bound variable
$$ of type Rule.Helper. Each time a rule is triggered a Helper
instance is used to store the table of bindings for the trigger method
arguments $0, $1 etc and for event variables. Every public instance
method on class Helper is automatically available as a callable
function in a rule binding, condition or action. For example, Helper
defines a boolean method debug(String) which prints text to
System.out. So, a call to debug("call to debug") will result in a call
to the hhelper's instance method (n.b. debug always returns true,
allowing it to be composed in AND conditions as well invoked as an
action).

Helper provides other builtins which allow countdowns to be initiated,
detected and decremented and allows threads to be blocked on a wait,
resumed and killed. Methods to support rendezvous will be added
soon. Adding a method to Helper automatically makes it available as a
builtin (type-checking happens automically too) so it should be easy
to extend the rule language as nw requirements arise.
